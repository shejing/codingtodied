# 块I/O层
+ 块设备：可以被随机访问固定大小数据片的设备，例如硬盘，闪存
+ 字符设备：按照字符流顺序访问的设备，例如键盘，串口
+ 块设备最小可寻址单元是**扇区**（质疑）
+ 内核执行的所有操作都是按块进行的，所以块比扇区大
+ **块**是文件系统最小寻址单元

## 缓冲区
当一个块被调入内存时，它要存储在一个缓冲区中，每个缓冲区对应一个块。每个缓冲区都有一个缓冲区头，用来描述磁盘块与物理内存缓冲区之间的映射。
以前的缓冲区是一段连续内存，刚好存储一个块，新的结构体bio将多个页面的空虚片段组织成一个缓冲区，该结构体包含了块IO操作所需的全部信息。
每个块IO请求都通过一个bio结构体表示，每个请求会涉及一个或者多个块，这些块的信息存储在bio结构体中。如果使用旧的缓冲区，在涉及多个块的IO操作中，就需要把IO操作分割，而bio结构体由于可以表示多个块，且不需要连续，所以可以一次保存多个块的信息。
虽然一个bio结构体可以表示多个块，但是要求这些块在块设备中是连续的，如果不是，就需要多个bio存储，而且bio存储的数据大小是有上限的，如果超过上限，也需要使用多个bio存储。
[bio结构体](https://blog.csdn.net/zhanghaiyang9999/article/details/81586385)

## 请求队列
块设备将所有的块IO请求保存在一个队列中，对应的块设备驱动程序会从队列中获取请求，然后执行。

## IO调度程序
目的是为了减少磁盘寻址时间，从而提高系统吞吐量。
+ 电梯调度 ： 执行合并与排序预处理，合并在块设备中相邻的块请求，按照磁盘寻址方向排序。当一个新的请求来临时，他可能会和其他请求合并，如果没有相邻的请求则在队列中按照寻址方向排序插入，如果队列中存在一个驻留时间过长的请求，则暂停排序，直接将请求放到队列末尾。
+ Deadline ： 最后期限调度，电梯调度算法中，如果一直有相邻的请求，则仍然会造成饥饿。Deadline算法使用四个队列，两个对写按照磁盘顺序排序的队列，两个读写按照超时时间排序的FIFO队列，也就是有两个读，两个写队列。读请求的优先级高，且超时时间短。当有一个新的请求进来时，他会根据读写类型放入排序队列中，排序队列同电梯调度算法一样，会进行排序合并。同时他会被放入FIFO队列中，如果FIFO队列中有请求超时，则立即执行超时请求。该算法减少了请求饥饿的现象，同时保证了读请求的优先级。
+ 预测IO   ： 当系统处于繁重的写操作期间时，每当提交一次读请求，系统会迅速处理读请求，然后再写。并且每次读请求都会执行这样的操作，即使是两次连续的读请求。这样严重损害了全局吞吐量。预测IO算法在请求提交后并不直接执行，而是等待一段时间，这段时间可能有连续的读请求提交，如果读请求是相邻的，那么可以合并读请求，从而节省了多次寻址的时间。
+ 完全公正队列(CFQ) ： 每个进程使用一个队列，使用轮询的方式调度队列，保证了每个进程拥有公平的带宽。
+ 空操作(Noop) ： 对于闪存，固态等不需要寻道，可以直接随机获取的块设备，也就不需要对请求进行排序了，所以空操作算法只对相邻的请求进行合并。这种算法是专门为这种设备设计的。
linux中块设备调度的缺省算法是CFQ算法。
