# 内存管理

## 页
+ 内核将物理页作为内存管理的基本单位
+ struct page 用于描述每个物理页，该结构体定义在<linux/mm_types.h>中
+ page结构是与物理页相关的，描述物理内存本身
+ 每个物理页都分配这样一个结构体

## 区
+ 高端内存和低端内存 ：  i386的4G进程空间典型的是3Guser + 1G kernel 的划分。那按前面的线性方法， 1G 内核空间，只能映射 1G 物理地址空间，这对内核来说太少了（这种情况下，内核无法使用超过1G的物理内存）。所以，折衷方案是， Linux 内核只对 1G 内核空间的前 896 MB 按前面所说的方法做线性映射, 剩下的 128 MB 的内核空间， 采用动态映射的方式，即按需映射的方式，这样，内核态的访问空间更多了。 这个直接映射的部分， 就是所谓的 NORMAL 区， 也就是所谓低端内存，而动态映射的部分，就是所谓高端内存。

+ 高端内存通过动态的映射物理内存的方式，操作任意的物理内存区域. [高端内存简介](https://blog.csdn.net/gqtcgq/article/details/52769358)

+ 有些体系结构中，只有固定的区域可以供DMA使用，这样的区域称为DMA区

区|描述|物理内存
---|---|---|
ZONE_DMA|DMA使用的页|<16MB
ZONE_NORMAL|正常可寻址的页|16~896MB
ZONE_HIGHMEM|高端内存|>896MB

+ 每个区使用struct zone表示，该结构体定义在<linux/mmzone.h>中

## 获得页
函数|功能
---|---|
alloc_pages()/free_pages()|获取或者释放连续的物理页
kmalloc()/kfree()|获取或者释放连续的以字节为单位的内核内存
vmalloc()/vfree()|功能同kmalloc()但是只要求在虚拟地址是连续的，物理地址无需连续

## slab层
+ 维护一个空闲列表，空闲列表中保存着已分配好的某个类型的数据结构块，当需要某个类型的数据时，直接从空闲列表中获取一个，而不需要分配内存，当不再需要这个对象时，就将其放入空闲列表中，这样避免了常用对象需要经常分配内存的开销
+ 为不同类型的对象，创建不同的高速缓存，该缓存中保存了所有的对象，需要某个类型的对象时，只需要调用** kmem_cache_alloc() **函数在对应的高速缓存中取出对象即可，不需要从头开始分配内存 
+ 高速缓存划分为slab，每个slab由一个或多个连续的物理页构成，每个slab中保存了多个指定类型的对象，所有的slab组织成三个链表，**slabs_full, slabs_partial, slabs_empty**, 表示slab的三种状态。
+ slab层在没有部分满和空的slab时分配新的slab
+ slab层在内存紧缺的时候释放slab占用的内存
+ slab层负责管理这些内存，作用就是一个专用的分配器，应用程序只需要创建对应的高速缓存就能直接使用，不需要管理这些内存

## 在栈上的静态分配
+ 内核栈保存进程在内核态运行的相关信息,内核栈的大小可以是1～2页
+ 中断栈为每个进程提供一个用于中断处理程序的栈
+ 内核栈空间比较小，如果在栈上进行大量的静态分配(分配大型数组等)行为可能导致栈溢出，溢出的栈会覆盖掉其他的数据，所以大型的数据结构应该使用动态分配

## 高端内存映射
+ 高端内存指物理地址超出内核地址空间部分的物理内存，该内存可以通过**alloc_pages()**获取相应的页，但是该页不会有对应的逻辑地址，如果要使用这段内存，就需要把这个页映射到一段内核地址空间，这段空间就叫做永久内核映射空间，这种映射就叫做永久映射，永久映射通过函数**kmap()**完成。
+ [永久映射和临时映射](https://developer.aliyun.com/article/20623)
+ 没看懂临时映射是什么

## 每个CPU的分配
+ 每个cpu的分配是指 存在一个数组，数组中每一项对应一个cpu，保存了对应cpu特有的数据。
+ 通过**alloc_percpu(type)**即可为每个cpu分配一个type类型的数据。
